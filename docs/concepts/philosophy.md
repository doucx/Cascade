# 核心哲学：万物皆为可计算值

`Cascade` 的设计基于一个简单而强大的哲学：**工作流中的每一个节点，无论它来自 Python 代码、配置文件还是外部命令，都是一个“可计算值” (Computable Value)。**

告别将不仅相同，而且难以组合的“配置”、“脚本”和“任务”区分对待的旧思维。在 Cascade 中，它们是统一的。

## 三大支柱

### 1. `LazyResult`: 对未来值的承诺

当您在 `Cascade` 中定义一个计算步骤时（例如调用一个 `@task` 函数，或者声明一个配置依赖），它**不会**立即执行。

相反，`Cascade` 会立即返回一个 `LazyResult` 对象。
*   这是一个对未来某个值的“承诺”。
*   这个对象是轻量级的，它仅仅包含了计算该值所需的一切信息：**计算逻辑**（"怎么做"）和**依赖关系**（"需要什么"）。
*   因为它是懒惰的，您可以自由地传递它、组合它，甚至将其作为条件，而在真正需要结果之前不会触发任何副作用。

### 2. 统一依赖图 (The Unified Graph)

这也是为什么 `Cascade` 被称为“统一”自动化库的原因。

当您将一个 `LazyResult` 作为一个参数传递给另一个计算步骤时，`Cascade` 并不是在传递值，而是在**构建图**。所有的 `LazyResult` 在后台连接成了一个巨大的、统一的有向无环图 (DAG)。

这个图不仅包含 Python 函数调用，还包含：
*   **Shell 命令** (`cs.shell`)
*   **配置查找** (`cs.config`)
*   **文件读取** (`cs.file`) #Deprecation
*   **数据库查询** (`cs.sql`)
*   **API 请求** (`cs.http`)

在这个图中，一个数据库查询的结果可以无缝地流向一个 Shell 命令，只需将前者的 `LazyResult` 传给后者即可。

### 3. 按需执行 (On-demand Execution)

这是 `Cascade` 能够极其高效的“魔法”所在。

因为我们拥有完整的依赖图，`Cascade` 可以在执行前进行全局优化。当您请求某个最终结果（Target）时，`Cascade` 引擎会：
1.  **反向追踪**: 从目标节点开始，向上追踪所有必须的依赖。
2.  **剪枝**: 只有那些为了计算最终结果所**必须**的节点才会被标记为执行。图中其他无关的分支会被完全忽略。
3.  **并发调度**: 引擎会自动分析哪些节点互不依赖，并尽可能并行地执行它们。

这意味着，如果您只想要一个复杂工作流中的一小部分结果，您只需请求那一个结果，`Cascade` 绝不会浪费时间去计算您不需要的东西。
