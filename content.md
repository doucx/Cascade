好的，我理解了问题。IDE 中出现类型错误（飘红）和 Provider 自动补全失效，是典型的开发者体验 (DX) 问题，这严重影响了开发效率。根本原因在于 `scripts/generate_stubs.py` 脚本生成的 `.pyi` 类型存根文件存在逻辑缺陷。

我将生成一个计划来修复这个脚本。

## [WIP] fix: 修正存根生成脚本以修复 IDE 自动补全和类型检查

### 错误分析
你提供的反馈——“代码大片飘红”和“Provider 无法自动补全”——以及我对 `scripts/generate_stubs.py` 脚本的分析，共同指向一个根本原因：**脚本为子命名空间（如 `cs.io`）生成了错误的类型声明**。

具体来说，脚本在 `__init__.pyi` 文件中将子命名空间声明为 `io: Namespace`，其中 `Namespace` 被定义为 `Any` 类型。这相当于告诉类型检查器：“`cs.io` 可以是任何东西，我不知道它里面有什么”。这直接导致了两个问题：
1.  **自动补全失效**：当类型检查器看到 `Any`，它就放弃了任何进一步的分析，因此无法提供 `cs.io.local` 或 `cs.io.s3` 等成员的补全建议。
2.  **类型错误（飘红）**：因为 `cs.io` 的类型是 `Any`，当你访问 `cs.io.local` 时，类型检查器无法确认 `local` 成员的存在，在严格模式下会将其标记为潜在的类型错误。

脚本中存在一个更深层次的 Bug：它正确地生成了 `from . import io` 这样的子模块导入语句，但从未将这些语句写入最终的 `.pyi` 文件中，而是错误地使用了 `io: Namespace` 声明。

### 用户需求
核心需求是恢复流畅的 IDE 开发体验。这具体包括：
1.  在输入 `cs.io.` 等命名空间后，IDE 能够准确地提供 `local`, `s3` 等下一级成员的自动补全。
2.  消除由于类型存根文件不正确而导致的大量虚假类型错误（飘红）。

### 评论
这是一个高优先级的开发者体验 (DX) 问题。一个功能完备的自动补全和准确的类型检查环境是现代软件开发的基础设施，修复此问题能显著提升开发效率和代码质量。此次修复将直接解决问题的根源，使 Cascade 库的动态 Provider 结构能被静态分析工具正确理解。

### 目标
修改 `scripts/generate_stubs.py` 脚本，使其能够生成符合 PEP 484 规范的、正确的 `.pyi` 类型存根文件。

### 基本原理
正确的做法是，在一个包的 `__init__.pyi` 文件中，通过相对导入（`from . import <submodule>`）来重新导出其子模块，而不是将其声明为 `Any` 类型。

我将重构脚本中的 `_generate_level` 函数，确保：
1.  移除将子命名空间声明为 `Namespace` 的错误逻辑。
2.  将正确生成的子模块导入语句（`pyi_submodules` 列表中的内容）实际写入到 `.pyi` 文件中。
3.  将 Provider 的 `LazyFactory` 声明与子模块的导入语句清晰地分离开来，以提高生成文件的可读性。

### 标签
#intent/fix #flow/ready #priority/high #comp/build #scope/dx #ai/brainstorm #task/domain/tooling #task/object/stub-generator #task/action/bug-fix #task/state/begin

---

### Script

#### Acts 1: 修复存根生成逻辑

我将使用 `patch_file` 彻底替换 `_generate_level` 函数，以实现正确的 `.pyi` 文件生成逻辑。

~~~~~act
patch_file
scripts/generate_stubs.py
~~~~~
~~~~~python
def _generate_level(subtree: dict, current_dir: Path, is_root: bool = False):
    """
    Writes the __init__.pyi for the current level and recurses for sub-namespaces.
    """
    current_dir.mkdir(exist_ok=True)
    # CRITICAL FIX: Ensure the directory is a Python package by adding __init__.py
    (current_dir / "__init__.py").touch()
    init_pyi_path = current_dir / "__init__.pyi"

    pyi_imports = [
        "# This file is auto-generated by scripts/generate_stubs.py.",
        "# Do not edit this file directly.",
        "from cascade.spec.protocols import LazyFactory",
        "from typing import Any",
        "\nNamespace = Any\n",
    ]

    pyi_declarations = []
    pyi_submodules = []

    # If it's the root __init__.pyi, add the known SDK exports
    if is_root:
        pyi_imports.append("# --- Known SDK Exports ---")
        # Group imports by module for cleanliness
        imports_by_module = defaultdict(list)
        for name, module in KNOWN_SDK_EXPORTS.items():
            imports_by_module[module].append(name)

        for module, names in sorted(imports_by_module.items()):
            pyi_imports.append(f"from {module} import {', '.join(sorted(names))}")
        pyi_imports.append("\n# --- Discovered Providers ---")

    for name, value in sorted(subtree.items()):
        if isinstance(value, dict):  # It's a namespace
            pyi_declarations.append(f"{name}: Namespace")
            pyi_submodules.append(
                f"from . import {name}"
            )  # This is not strictly needed if we declare as Namespace
            # Recurse into the sub-directory
            _generate_level(value, current_dir / name)
        else:  # It's a terminal node (a provider function)
            pyi_declarations.append(f"{name}: LazyFactory")

    # Write the __init__.pyi file for the current level
    content = "\n".join(pyi_imports) + "\n" + "\n".join(pyi_declarations)

    with open(init_pyi_path, "w", encoding="utf-8") as f:
        f.write(content)
        f.write("\n")  # Ensure trailing newline

    print(f"  - Wrote {init_pyi_path.relative_to(PROJECT_ROOT)}")
~~~~~
~~~~~python
def _generate_level(subtree: dict, current_dir: Path, is_root: bool = False):
    """
    Writes the __init__.pyi for the current level and recurses for sub-namespaces.
    """
    current_dir.mkdir(exist_ok=True)
    # CRITICAL: Ensure the directory is a Python package by adding __init__.py
    (current_dir / "__init__.py").touch()
    init_pyi_path = current_dir / "__init__.pyi"

    # --- Base header for all .pyi files ---
    content_lines = [
        "# This file is auto-generated by scripts/generate_stubs.py.",
        "# Do not edit this file directly.",
    ]

    # --- Lists to hold discovered members ---
    pyi_providers = []
    pyi_namespaces = []

    # --- Re-export known SDK members ONLY in the root __init__.pyi ---
    if is_root:
        content_lines.append("\n# --- Known SDK Exports ---")
        imports_by_module = defaultdict(list)
        for name, module in KNOWN_SDK_EXPORTS.items():
            imports_by_module[module].append(name)

        for module, names in sorted(imports_by_module.items()):
            content_lines.append(f"from {module} import {', '.join(sorted(names))}")
        content_lines.append("\n# --- Discovered Providers ---")

    # --- Separate providers (terminals) from namespaces (sub-trees) ---
    for name, value in sorted(subtree.items()):
        if isinstance(value, dict):
            pyi_namespaces.append(name)
            # Recurse into the sub-directory
            _generate_level(value, current_dir / name)
        else:
            pyi_providers.append(name)

    # --- Assemble the final .pyi content ---

    # 1. Add LazyFactory import only if there are actual providers at this level
    if pyi_providers:
        content_lines.append("from cascade.spec.protocols import LazyFactory")
        content_lines.extend(f"{name}: LazyFactory" for name in pyi_providers)

    # 2. Re-export sub-namespaces to make them discoverable by type checkers
    if pyi_namespaces:
        if pyi_providers:
            content_lines.append("")  # Add a blank line for readability
        content_lines.extend(f"from . import {name}" for name in pyi_namespaces)

    # --- Write the __init__.pyi file for the current level ---
    content = "\n".join(content_lines)
    with open(init_pyi_path, "w", encoding="utf-8") as f:
        f.write(content)
        f.write("\n")  # Ensure trailing newline

    print(f"  - Wrote {init_pyi_path.relative_to(PROJECT_ROOT)}")
~~~~~

### 下一步建议
计划执行成功后，`generate_stubs.py` 脚本就已经被修复了。你需要执行以下步骤来让改动生效：

1.  **运行脚本**：在你的项目根目录运行命令 `python scripts/generate_stubs.py`。
2.  **重启语言服务器**：在 VS Code 中，打开命令面板 (Ctrl+Shift+P)，然后运行 "Developer: Reload Window" 或 "Python: Restart Language Server" 命令。这将强制 Pylance/Pyright 重新加载新的、正确的类型存根。

完成以上步骤后，IDE 的自动补全和类型检查功能应该就能恢复正常。
